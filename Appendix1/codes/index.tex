%!TEX root = ../thesis.tex
% ******************************* Thesis Appendix A ****************************

the \textbf{src/index/index.h} file
\begin{lstlisting}[style=CStyle]
#ifndef SITEPERCOLATION_INDEX_H
#define SITEPERCOLATION_INDEX_H

#include <ostream>
#include <iostream>
#include <sstream>
#include <vector>

#include "../types.h"
#include "../exception/exceptions.h"
#include "../lattice/bond_type.h"


struct Index{
value_type row_{};
value_type column_{};

~Index()                      = default;
Index()                       = default;

Index(value_type x, value_type y) : row_{x}, column_{y} {}

};


class IndexRelative{
public:
int x_{};
int y_{};

~IndexRelative()                      = default;
IndexRelative()                       = default;

IndexRelative(int x, int y) : x_{x}, y_{y} {}

};

struct BondIndex{
BondType bondType;

value_type row_;
value_type column_;

~BondIndex()                        = default;
BondIndex()                         = default;

BondIndex(BondType hv, value_type row, value_type column)
:  row_{row}, column_{column}
{
bondType = hv;
}

bool horizontal() const { return bondType == BondType::Horizontal;}
bool vertical() const { return bondType == BondType::Vertical;}

};


std::ostream& operator<<(std::ostream& os, const Index& index);
bool operator==(const Index& index1, const Index& index2);
bool operator<(const Index& index1, const Index& index2);

std::ostream& operator<<(std::ostream& os, const IndexRelative& index);

std::ostream& operator<<(std::ostream& os, const BondIndex& index);
bool operator==(BondIndex index1, BondIndex index2);
bool operator<(BondIndex index1, BondIndex index2);


/**
*  Get 2nd nearest neightbor / sin the direction of 1st nearest neighbor, while @var center is the center
*/
Index get_2nn_in_1nn_direction(Index center, Index nn_1, value_type length);
std::vector<Index> get_2nn_s_in_1nn_s_direction(Index center, const std::vector<Index> &nn_1, value_type length);

#endif /* SITEPERCOLATION_INDEX_H */
\end{lstlisting}


The \textbf{src/index/index.cpp} file
\begin{lstlisting}[style=CStyle]
#include <iomanip>
#include "index.h"

using namespace std;

ostream& operator<<(ostream& os, const Index& index)
{
return os <<'(' << index.row_ << ',' << index.column_ << ')';
}

ostream& operator<<(ostream& os, const IndexRelative& index)
{
return os << '(' << std::setw(3) << index.x_ << ',' << std::setw(3) << index.y_ << ')';
}

bool operator==(const Index& index1, const Index& index2){
return (index1.row_ == index2.row_) && (index1.column_ == index2.column_);
}

bool operator<(const Index& index1, const Index& index2){
if(index1.row_ < index2.row_)
return true;
if(index1.row_ == index2.row_){
return index1.column_ < index2.column_;
}
return false;
}

ostream& operator<<(ostream& os, const BondIndex& index){
if(index.horizontal()){
// horizontal bond
os << "<->" ;
}
if (index.vertical()){
// vertical bond
os << "<|>" ;
}
return os << '(' << index.row_ << ',' << index.column_ << ')';
}

bool operator==(BondIndex index1, BondIndex index2){
if(index1.horizontal() ==  index2.horizontal() || index1.vertical() ==  index2.vertical()){
// horizontal or vertical
return index1.row_ == index2.row_ && index1.column_ == index2.column_;
}
return false;
}


bool operator<(BondIndex index1, BondIndex index2){
cout << "not yet defined : line " << __LINE__ << endl;
return false;
}


/**
* Get the 2nd nearest nearest neighbor in the direction of 1st nearest neighbor.
* Periodicity is not considered here.
*/
Index get_2nn_in_1nn_direction(Index center, Index nn_1, value_type length){
int delta_c = int(nn_1.column_) - int(center.column_);
int delta_r = int(nn_1.row_) - int(center.row_);
if (delta_c == 0 && delta_r == 0){
cout << "Both indices are same : line " << __LINE__ << endl;
}
else if(delta_c > 1 || delta_r > 1){
// meaning, the sites are on the opposite edges
//        cout << "2nd index is not the First nearest neighbor : line " << __LINE__ << " : file " << __FILE__ << endl;
}

return Index{(nn_1.row_ + delta_r + length) % length, (nn_1.column_ + delta_c + length) % length};
}


/**
* Get all second nearest neighbors based on the first nearest neighbors.
* Periodicity is not considered here
*/
vector<Index> get_2nn_s_in_1nn_s_direction(Index center, const vector<Index> &nn_1, value_type length){
vector<Index> nn_2(nn_1.size());

for(size_t i{}; i != nn_1.size() ; ++i){
int delta_c = int(nn_1[i].column_) - int(center.column_);
int delta_r = int(nn_1[i].row_) - int(center.row_);
if (delta_c == 0 && delta_r == 0){
cout << "Both indices are same : line " << __LINE__ << endl;
}
else if(delta_c > 1 || delta_r > 1){
// meaning, the sites are on the opposite edges
//            cout << "center " << center << " nn " << nn_1 << endl;
//            cout << "2nd index is not the First nearest neighbor : line " << __LINE__ << " : file " << __FILE__ << endl;
}

nn_2[i] =  Index{(nn_1[i].row_ + delta_r + length) % length, (nn_1[i].column_ + delta_c + length) % length};
}
return nn_2;
}
\end{lstlisting}

