%!TEX root = ../thesis.tex
% ******************************* Thesis Appendix A ****************************

the \textbf{src/lattice/lattice.h} file
\begin{lstlisting}[style=CStyle]
#ifndef SITEPERCOLATION_LATTICE_H
#define SITEPERCOLATION_LATTICE_H

#include <vector>
#include <cmath>
#include "../percolation/cluster.h"
#include "../types.h"
#include "site.h"
#include "bond.h"

/**
* The square Lattice
* Site and Bonds are always present But they will not be counted unless they are activated
* always return by references, so that values in the class itself is modified
*/
class SqLattice {
std::vector<std::vector<Site>> _sites;  // holds all the sites
std::vector<std::vector<Bond>> _h_bonds;  // holds all horizontal bonds
std::vector<std::vector<Bond>> _v_bonds;  // holds all vertical bonds

bool _bond_resetting_flag=true; // so that we can reset all bonds
bool _site_resetting_flag=true; // and all sites

value_type _length{};

private:
void reset_sites();
void reset_bonds();
public:
~SqLattice() = default;
SqLattice() = default;
SqLattice(SqLattice&) = default;
SqLattice(SqLattice&&) = default;
SqLattice& operator=(const SqLattice&) = default;
SqLattice& operator=(SqLattice&&) = default;

SqLattice(value_type length, bool activate_bonds, bool activate_sites, bool bond_reset, bool site_reset);

void reset(bool reset_all=false);

/***************************************
* I/O functions : declarations and definitions are in github
**************************************/

/************************************
* Activation functions
***********************************/
void activate_site(Index index);
void activateBond(BondIndex bond);

void deactivate_site(Index index);
void deactivate_bond(Bond bond);

value_type length() const { return  _length;}

Site& getSite(Index index);
Bond& getBond(BondIndex);

const Site& getSite(Index index) const ;
const Bond& getBond(BondIndex index) const ;

void setGroupID(Index index, int group_id);
void setGroupID(BondIndex index, int group_id);
const int getGroupID(Index index)const;
const int getGroupID(BondIndex index)const;

/******************************************************************************
* Get Neighbor from given index
******************************************************************************/
std::vector<Index> get_neighbor_site_indices(Index site);   // site neighbor of site
std::vector<BondIndex> get_neighbor_bond_indices(BondIndex site); // bond neighbor of bond
std::vector<Index> get_neighbor_indices(BondIndex bond);   // two site neighbor of bond.

static std::vector<Index> get_neighbor_site_indices(size_t length, Index site);   // 4 site neighbor of site
static std::vector<BondIndex> get_neighbor_bond_indices(size_t length, BondIndex site); // 6 bond neighbor of bond
static std::vector<Index> get_neighbor_indices(size_t length, BondIndex bond);   // 2 site neighbor of bond.

};


#endif //SITEPERCOLATION_LATTICE_H
\end{lstlisting}


The \textbf{src/lattice/lattice.cpp} file
\begin{lstlisting}[style=CStyle]
#include <iomanip>
#include "lattice.h"
#include "../util/printer.h"

using namespace std;

/**
*
* @param length         -> length of the lattice
* @param activate_bonds -> if true all bonds are activated by default
*                          and will not be deactivated as long as the object exists,
*                          even if SLattice::reset function is called.
* @param activate_sites -> if true all sites are activated by default
*                          and will not be deactivated as long as the object exists,
*                          even if SLattice::reset function is called.
*/
SqLattice::SqLattice(
value_type length,
bool activate_bonds, bool activate_sites,
bool bond_reset, bool site_reset)
: _length{length}, _bond_resetting_flag{bond_reset}, _site_resetting_flag{site_reset}
{
cout << "Constructing Lattice object : line " << __LINE__ << endl;
_sites = std::vector<std::vector<Site>>(_length);
_h_bonds = std::vector<std::vector<Bond>>(_length);
_v_bonds = std::vector<std::vector<Bond>>(_length);
if(!activate_bonds && !activate_sites) {    // both are deactivated by default
for (value_type i{}; i != _length; ++i) {
_sites[i] = std::vector<Site>(_length);
_h_bonds[i] = std::vector<Bond>(_length);
_v_bonds[i] = std::vector<Bond>(_length);
for (value_type j{}; j != _length; ++j) {
_sites[i][j] = Site(Index(i, j), _length);
_h_bonds[i][j] = {Index(i, j), Index(i, (j + 1) % _length), _length};
_v_bonds[i][j] = {Index(i, j), Index((i + 1) % _length, j), _length};
}
}
}
else if(activate_bonds && !activate_sites) {    // all bonds are activated by default
for (value_type i{}; i != _length; ++i) {
_sites[i] = std::vector<Site>(_length);
_h_bonds[i] = std::vector<Bond>(_length);
_v_bonds[i] = std::vector<Bond>(_length);
for (value_type j{}; j != _length; ++j) {
_sites[i][j] = Site(Index(i, j), _length);
_h_bonds[i][j] = {Index(i, j), Index(i, (j + 1) % _length), _length};
_v_bonds[i][j] = {Index(i, j), Index((i + 1) % _length, j), _length};
_h_bonds[i][j].activate();
_v_bonds[i][j].activate();
}
}
}
else if(!activate_bonds && activate_sites) {    // all sites are activated by default
for (value_type i{}; i != _length; ++i) {
_sites[i] = std::vector<Site>(_length);
_h_bonds[i] = std::vector<Bond>(_length);
_v_bonds[i] = std::vector<Bond>(_length);
for (value_type j{}; j != _length; ++j) {
_sites[i][j] = Site(Index(i, j), _length);
_sites[i][j].activate();
_h_bonds[i][j] = {Index(i, j), Index(i, (j + 1) % _length), _length};
_v_bonds[i][j] = {Index(i, j), Index((i + 1) % _length, j), _length};
}
}
}
else {
for (value_type i{}; i != _length; ++i) {   // all bonds and sites are activated by default
_sites[i] = std::vector<Site>(_length);
_h_bonds[i] = std::vector<Bond>(_length);
_v_bonds[i] = std::vector<Bond>(_length);
for (value_type j{}; j != _length; ++j) {
_sites[i][j] = Site(Index(i, j), _length);
_sites[i][j].activate();
_h_bonds[i][j] = {Index(i, j), Index(i, (j + 1) % _length), _length};
_v_bonds[i][j] = {Index(i, j), Index((i + 1) % _length, j), _length};
_h_bonds[i][j].activate();
_v_bonds[i][j].activate();
}
}
}

}

/************************************************
* Activation and Deactivation
*************************************************/
void SqLattice::activate_site(Index index) {
_sites[index.row_][index.column_].activate();
}

void SqLattice::activateBond(BondIndex bond) {
// check if the bond is vertical or horizontal
// then call appropriate function to activate _h_bond or _v_bond
if(bond.horizontal()){ // horizontal
if(_h_bonds[bond.row_][bond.column_].isActive()){
cout << "Bond is already activated : line " << __LINE__ << endl;
}
_h_bonds[bond.row_][bond.column_].activate();
}
else if(bond.vertical()) // vertical
{
if(_v_bonds[bond.row_][bond.column_].isActive()){
cout << "Bond is already activated : line " << __LINE__ << endl;
}
_v_bonds[bond.row_][bond.column_].activate();
}
else{
cout << bond << " is not a valid bond : line " << __LINE__ << endl;
}
}

void SqLattice::deactivate_site(Index index){
_sites[index.row_][index.column_].deactivate();
}

void SqLattice::deactivate_bond(Bond bond) {
// check if the bond is vertical or horizontal
// then call appropriate function to activate _h_bond or _v_bond
if(bond.isHorizontal()){
if(_h_bonds[bond.id().row_][bond.id().column_].isActive()){
cout << "Bond is already activated : line " << __LINE__ << endl;
}
_h_bonds[bond.id().row_][bond.id().column_].deactivate();
}
else if(bond.isVertical())
{
if(_v_bonds[bond.id().row_][bond.id().column_].isActive()){
cout << "Bond is already activated : line " << __LINE__ << endl;
}
_v_bonds[bond.id().row_][bond.id().column_].deactivate();
}
else{
bond.activate();
cout << bond << " is not a valid bond : line " << __LINE__ << endl;
}
}

/*********************************************************
* Viewing methods
*********************************************************/



Site& SqLattice::getSite(Index index) {
return _sites[index.row_][index.column_];
}


const Site& SqLattice::getSite(Index index) const {
return _sites[index.row_][index.column_];
}

const Bond& SqLattice::getBond(BondIndex index) const {
if (index.horizontal()) {
return _h_bonds[index.row_][index.column_];
}
if (index.vertical()) {
return _v_bonds[index.row_][index.column_];
}
throw InvalidBond{"Invalid bond : line " + to_string(__LINE__)};
}

void SqLattice::setGroupID(Index index, int group_id){
_sites[index.row_][index.column_].set_groupID(group_id);
}

void SqLattice::setGroupID(BondIndex index, int group_id){
if(index.horizontal()){
_h_bonds[index.row_][index.column_].set_groupID(group_id);
}
if(index.vertical()){
_v_bonds[index.row_][index.column_].set_groupID(group_id);
}
}

const int SqLattice::getGroupID(Index index)const{
return _sites[index.row_][index.column_].get_groupID();
}

const int SqLattice::getGroupID(BondIndex index)const{
if(index.horizontal()){
return _h_bonds[index.row_][index.column_].get_groupID();
}
if(index.vertical()){
return  _v_bonds[index.row_][index.column_].get_groupID();
}
return -1;
}


Bond& SqLattice::getBond(BondIndex index) {
if(index.horizontal())
return _h_bonds[index.row_][index.column_];
if(index.vertical())
return _v_bonds[index.row_][index.column_];
throw InvalidBond{"Invalid bond : line " + to_string(__LINE__)};
}

void SqLattice::reset(bool reset_all) {
if(reset_all){
reset_sites();
reset_bonds();
return;
}
// setting all group id to -1
if(_site_resetting_flag) {
reset_sites();
}
//    cout << "Bond resetting is disabled : line " << __LINE__ << endl;
if(_bond_resetting_flag) {
reset_bonds();
}

}


void SqLattice::reset_bonds() {
for(value_type i{}; i != _h_bonds.size(); ++i){
for (int j{}; j != _h_bonds[i].size(); ++j) {
// deactivating. automatically set group id == - and relative index == (0,0)
// setting group id = -1 and deactivating the bond
_h_bonds[i][j].deactivate();
_v_bonds[i][j].deactivate();

}
}
}


void SqLattice::reset_sites() {
for(value_type i{}; i != _sites.size(); ++i){
for(value_type j{}; j != _sites[i].size(); ++j) {
// deactivating. automatically set group id == - and relative index == (0,0)
// setting group id = -1 and deactivating the site
_sites[i][j].deactivate();
}
}
}


/******************************************************************************
* Get Neighbor from given index
******************************************************************************/
/**
* Periodic case only.
* Each site has four neighbor sites.
* @param site
* @return
*/
std::vector<Index> SqLattice::get_neighbor_site_indices(Index site){
std::vector<Index> sites(4);
sites[0] = {(site.row_ + 1) % _length, site.column_};
sites[1] = {(site.row_ - 1 + _length) % _length, site.column_};
sites[2] = {site.row_, (site.column_ + 1) % _length};
sites[3] = {site.row_, (site.column_ - 1 + _length) % _length};
return sites;
}

/**
* Periodic case only.
* Each bond has six neibhbor bonds.
*/
std::vector<BondIndex> SqLattice::get_neighbor_bond_indices(BondIndex bond) {
value_type next_column = (bond.column_ + 1) % _length;
value_type prev_column = (bond.column_ - 1 + _length) % _length;
value_type prev_row = (bond.row_ - 1 + _length) % _length;
value_type next_row = (bond.row_ + 1) % _length;

vector<BondIndex> bonds(6);

// horizontal bond case
if (bond.horizontal()) {
// increase column index for the right neighbor

// left end of bond
bonds[0] = {BondType::Vertical, bond.row_, bond.column_};
bonds[1] = {BondType::Vertical, prev_row, bond.column_};
bonds[2] = {BondType::Horizontal, bond.row_, prev_column};

// right end bond
bonds[3] = {BondType::Vertical, prev_row, next_column};
bonds[4] = {BondType::Vertical, bond.row_, next_column};
bonds[5] = {BondType::Horizontal, bond.row_, next_column};

}
// vertical bond case
else if (bond.vertical()) {
// increase row index

// top end of bond
bonds[0] = {BondType::Horizontal, bond.row_, bond.column_};
bonds[1] = {BondType::Horizontal, bond.row_, prev_column};
bonds[2] = {BondType::Vertical, prev_row, bond.column_};

// bottom end of bond
bonds[3] = {BondType::Horizontal, next_row, bond.column_};
bonds[4] = {BondType::Horizontal, next_row, prev_column};
bonds[5] = {BondType::Vertical, next_row, bond.column_};

}

return bonds;
}

std::vector<Index> SqLattice::get_neighbor_indices(BondIndex bond) {
value_type r = bond.row_;
value_type c = bond.column_;
vector<Index> sites(2);
sites[0] = {r, c};
if(bond.horizontal()){
sites[1] = {r, (c+1) % _length};
}else{
sites[1] = {(r+1) % _length, c};
}
return sites;
}

/************************************************************
* Static methods
*/
std::vector<Index> SqLattice::get_neighbor_site_indices(size_t length, Index site){
std::vector<Index> sites(4);
sites[0] = {(site.row_ + 1) % length, site.column_};
sites[1] = {(site.row_ - 1 + length) % length, site.column_};
sites[2] = {site.row_, (site.column_ + 1) % length};
sites[3] = {site.row_, (site.column_ - 1 + length) % length};
return sites;
}

/**
* Periodic case only.
* Each bond has six neibhbor bonds.
*/
std::vector<BondIndex> SqLattice::get_neighbor_bond_indices(size_t length, BondIndex bond) {
value_type next_column = (bond.column_ + 1) % length;
value_type prev_column = (bond.column_ - 1 + length) % length;
value_type prev_row = (bond.row_ - 1 + length) % length;
value_type next_row = (bond.row_ + 1) % length;

vector<BondIndex> bonds(6);

// horizontal bond case
if (bond.horizontal()) {
// increase column index for the right neighbor

// left end of bond
bonds[0] = {BondType::Vertical, bond.row_, bond.column_};
bonds[1] = {BondType::Vertical, prev_row, bond.column_};
bonds[2] = {BondType::Horizontal, bond.row_, prev_column};

// right end bond
bonds[3] = {BondType::Vertical, prev_row, next_column};
bonds[4] = {BondType::Vertical, bond.row_, next_column};
bonds[5] = {BondType::Horizontal, bond.row_, next_column};

}
// vertical bond case
else if (bond.vertical()) {
// increase row index

// top end of bond
bonds[0] = {BondType::Horizontal, bond.row_, bond.column_};
bonds[1] = {BondType::Horizontal, bond.row_, prev_column};
bonds[2] = {BondType::Vertical, prev_row, bond.column_};

// bottom end of bond
bonds[3] = {BondType::Horizontal, next_row, bond.column_};
bonds[4] = {BondType::Horizontal, next_row, prev_column};
bonds[5] = {BondType::Vertical, next_row, bond.column_};

}

return bonds;
}

std::vector<Index> SqLattice::get_neighbor_indices(size_t length, BondIndex bond) {
value_type r = bond.row_;
value_type c = bond.column_;
vector<Index> sites(2);
sites[0] = {r, c};
if(bond.horizontal()){
sites[1] = {r, (c+1) % length};
}else{
sites[1] = {(r+1) % length, c};
}
return sites;
}

\end{lstlisting}

