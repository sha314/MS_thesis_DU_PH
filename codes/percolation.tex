%!TEX root = ../thesis.tex
% ******************************* Thesis Appendix A ****************************

The \textbf{src/percolation/percolation.h} file

\begin{lstlisting}[style=CStyle]
#ifndef SITEPERCOLATION_PERCOLATION_H
#define SITEPERCOLATION_PERCOLATION_H


#include <vector>
#include <set>
#include <unordered_set>
#include <map>
#include <climits>
#include <fstream>


#include "../types.h"
#include "../lattice/lattice.h"
#include "../index/index.h"

#include <random>


/**
* The Square Lattice Percolation class
*/
class SqLatticePercolation{
// constants
value_type  _length;
value_type _max_number_of_bonds;
value_type _max_number_of_sites;
char type{'0'}; // percolation type. 's' -> site percolation. 'b' -> bond percolation
protected:

// structural variables of lattice
SqLattice _lattice;

value_type _index_sequence_position{};

std::vector<Cluster> _clusters;   // check and remove reapeted index manually
// every birthTime we create a cluster we assign an set_ID for them

double _occuption_probability {};
// entropy
double _entropy{};
double _entropy_current{};
size_t _cluster_count{};
value_type _bonds_in_cluster_with_size_two_or_more{0};   // total number of bonds in the clusters. all cluster has bonds > 1
bool _reached_critical = false; // true if the system has reached critical value

value_type _total_relabeling{};
double time_relabel{};
value_type _number_of_occupied_sites{};
value_type _max_iteration_limit{};
std::random_device _random_device;
std::mt19937 _random_generator;

void set_type(char t){type = t;} // setting percolation type
public:
static constexpr const char* signature = "SqLatticePercolation";

virtual ~SqLatticePercolation() = default;
SqLatticePercolation(value_type length);
void reset();


bool occupy();
value_type length() const { return _length;}
value_type maxSites() const {return _max_number_of_sites;}
value_type maxBonds() const { return _max_number_of_bonds;}

/*********
*  I/O functions
*/
virtual void viewCluster();
virtual void viewClusterExtended();
virtual void view_bonds(){
_lattice.view_bonds();
}
virtual void viewLattice(){
_lattice.view_sites();

}

/**
* Also shows the cluster index of the sites
*/
virtual void viewLatticeExtended(){
_lattice.view_sites_extended();
}

/**
* Displays group ids of sites in a matrix form
*/
virtual void viewLatticeByID(){
_lattice.view_sites_by_id();
_lattice.view_bonds_by_id();
}

virtual void viewSiteByID(){
_lattice.view_sites_by_id();
}

virtual void viewBondByID(){
_lattice.view_bonds_by_id();
}

virtual void viewSiteByRelativeIndex(){
_lattice.view_sites_by_relative_index();
}
virtual void viewBondByRelativeIndex(){
_lattice.view_bonds_by_relative_index_v4();
}

virtual void viewByRelativeIndex(){
_lattice.view_by_relative_index();
}

virtual void view(){
_lattice.view();
}

virtual double occupationProbability() const { return _occuption_probability;}
virtual double entropy() { return _entropy_current;}
double entropy_by_site(); // for future convenience. // the shannon entropy. the full calculations. time consuming
double entropy_by_bond(); // for future convenience. // the shannon entropy. the full calculations. time consuming
size_t numberOfcluster() const {return _cluster_count;}

void get_cluster_info(
std::vector<value_type> &site,
std::vector<value_type> &bond
);

char get_type() const {return type;} // get percolation type
virtual value_type maxIterationLimit() {return _max_iteration_limit;};

double get_relabeling_time() const {return time_relabel;}
value_type relabeling_count() const {return _total_relabeling;}
};


/**
* Site Percolation by Placing Sites
*
* version 9
*
* First it randomizes the site index list then use it.
* Paradigm Shift:
* Does not delete cluster only makes it empty so that index and id remains the same.
* This way Searching for index of the cluster using id can be omitted.
*
* Feature :
* 1. Can turn on and off both horizontal and boundary condition
*
* 2. Uses class Cluster_v2 for storing clusters
*
* 3. Uses Group_ID for Bonds and Sites to identify that they are in the same cluster
*
* 4. Occupation probability is calculated by sites,
*      i.e., number of active sites divided by total number of sites
*
* 5. Spanning is calculated by number of bonds in a spanning clusters with periodicity turned off,
*      i.e., number of bonds in the spanning clusters divided by total number of bonds
*
* 6. Unweighted relabeling is ommited in this version ??
*
* 7. Runtime is significantly improved. For example, if L=200 program will take ~1 min to place all sites.
*
* 8. Unnecessary methods of previous version is eliminated
*
* 9. Checking spanning by keeping track of boundary sites is implemented
*
* 10. last modified cluster id can be obtained from @var _last_placed_site
*
*
*/
class SitePercolation_ps_v9 : public SqLatticePercolation{
protected:
// flags to manipulate method
bool _periodicity{false};

value_type min_index; // minimum index = 0
value_type max_index; // maximum index = length - 1

// index sequence
std::vector<Index> index_sequence;  // initialized once
std::vector<value_type> randomized_index;

// every birthTime we create a cluster we assign an set_ID for them
int _cluster_id{};
value_type _index_last_modified_cluster{};  // id of the last modified cluster

// order parameter calculation ingradiants
// id of the cluster which has maximum number of bonds. used to calculate order parameter
value_type _number_of_bonds_in_the_largest_cluster{};
value_type _number_of_sites_in_the_largest_cluster{};   // might be useful later

Index _last_placed_site;    // keeps track of last placed site

/**************
* Spanning variables
************/
/*Holds indices on the edges*/
std::vector<Index> _top_edge, _bottom_edge, _left_edge, _right_edge;

std::vector<Index> _spanning_sites;
std::vector<Index> _wrapping_sites;
std::vector<value_type> number_of_sites_to_span;
std::vector<value_type> number_of_bonds_to_span;

value_type _total_relabeling{};

/*****************************************
* Private Methods
******************************************/
void relabel_sites(const std::vector<Index> &sites, int id_a, int delta_x_ab, int delta_y_ab) ;

double time_relabel{};
public:
static constexpr const char* signature = "SitePercolation_ps_v8";

~SitePercolation_ps_v9() = default;
SitePercolation_ps_v9() = default;
SitePercolation_ps_v9(SitePercolation_ps_v9 & ) = default;
SitePercolation_ps_v9(SitePercolation_ps_v9 && ) = default;
explicit SitePercolation_ps_v9(value_type length, bool periodicity=true);

SitePercolation_ps_v9& operator=(SitePercolation_ps_v9 & ) = default;
//    SitePercolation_ps_v8&& operator=(SitePercolation_ps_v8 && ) = default;
double get_relabeling_time() {return time_relabel;}
value_type relabeling_count() const {return _total_relabeling;}

virtual void reset();


bool periodicity() const {return _periodicity;}
std::string getSignature();


void add_entropy_for_bond(value_type index);
void subtract_entropy_for_bond(const std::set<value_type> &found_index_set, int base=-1);

/*************************************************
* Site placing methods
************************************************/
virtual bool occupy();
value_type placeSite_weighted(Index site); // uses weighted relabeling by first identifying the largest cluster
value_type placeSite_weighted(Index site,
std::vector<Index>& neighbor_sites,
std::vector<BondIndex>& neighbor_bonds);

Index selectSite(); // selecting site

void connection_v2(Index site, std::vector<Index> &site_neighbor, std::vector<BondIndex> &bond_neighbor);

// applicable to weighted relabeling
void relabel_sites_v5(Index root_a, const Cluster& clstr_b); // relative index is set accordingly

/**********************************************
* Information about current state of Class
**********************************************/
double numberOfOccupiedSite() const { return _number_of_occupied_sites;}
double occupationProbability() const { return double(_number_of_occupied_sites)/maxSites();}
double entropy(); // the shannon entropy

value_type numberOfBondsInTheLargestCluster_v2();
value_type numberOfSitesInTheLargestCluster();

value_type numberOfSitesInTheSpanningClusters_v2()  ;
value_type numberOfBondsInTheSpanningClusters_v2()  ;

value_type numberOfSitesInTheWrappingClusters()  ;
value_type numberOfBondsInTheWrappingClusters()  ;

/***********************************
* Spanning Detection
**********************************/
bool detectSpanning_v6(const Index& site);

bool check_if_id_matches(Index site, const std::vector<Index> &edge);

bool detectWrapping();

/************************************
*  Tracker
*  Must be called each time a site is placed
***********************************/
void track_numberOfBondsInLargestCluster();
void track_numberOfSitesInLargestCluster();

/*********************************
* I/O functions
* Printing Status
********************************/
Index lastPlacedSite() const { return _last_placed_site;}

void spanningIndices() const;
void wrappingIndices() const;

/***********************************************
* Visual data for plotting
*********************************************/
// lattice visual data for python
void writeVisualLatticeData(const std::string& filename, bool only_spanning=true);

protected:
void initialize();
void initialize_index_sequence();
void randomize_v2(); // better random number generator

int find_cluster_index_for_placing_new_bonds(const std::vector<Index> &neighbors, std::set<value_type> &found_indices);

value_type manage_clusters(
const std::set<value_type> &found_index_set,
std::vector<BondIndex> &hv_bonds,
Index &site,
int base_id // since id and index is same
);

public:
// on test
IndexRelative getRelativeIndex(Index root, Index site_new);
};

/*******************************************************************************
* Site Percolation Ballistic Deposition
* Extended from SitePercolation_ps_v9
* *************************************************************/
class SitePercolationBallisticDeposition_v2: public SitePercolation_ps_v9{
protected:
// elements of @indices_tmp will be erased if needed but not of @indices
std::vector<value_type> indices;
std::vector<value_type> indices_tmp;
public:
static constexpr const char* signature = "SitePercolation_BallisticDeposition_v2";
virtual ~SitePercolationBallisticDeposition_v2(){
indices.clear();
indices_tmp.clear();
};
SitePercolationBallisticDeposition_v2(value_type length, bool periodicity);

virtual bool occupy();

/************************************
* Site selection methods
*/
Index select_site(std::vector<Index> &sites, std::vector<BondIndex> &bonds);
Index select_site_upto_1nn(std::vector<Index> &sites, std::vector<BondIndex> &bonds);
Index select_site_upto_2nn(std::vector<Index> &sites, std::vector<BondIndex> &bonds);

void reset();
void initialize_indices();

virtual std::string getSignature() {
std::string s = "sq_lattice_site_percolation_ballistic_deposition_";
if(_periodicity)
s += "_periodic_";
else
s += "_non_periodic_";
return s;
}


/***********************************
* occupy upto 1st nearset neighbor.
* If the randomly selected site is occupied then select one of the nearest neighor randomly
* If it is also occupied skip the rest setps and start next iteration Else occupy it
*/
value_type placeSite_1nn_v2();
/*********************************
* occupy upto 2nd nearest neighbor.
* If the randomly selected site is occupied then select one of the nearest neighor randomly
* If it is also occupied, select the next neighbor in the direction of motion Else occupy it.
* If the 2nd nearest neighbor in the direction of motion is also occupied then skip the rest of the steps
*      and start the next iteration
*/
value_type placeSite_2nn_v1();

};

/***********
* Only L1
*/
class SitePercolationBallisticDeposition_L1_v2: public SitePercolationBallisticDeposition_v2{
public:
~SitePercolationBallisticDeposition_L1_v2() = default;
SitePercolationBallisticDeposition_L1_v2(value_type length, bool periodicity)
:SitePercolationBallisticDeposition_v2(length, periodicity){}

bool occupy() {
// if no site is available then return false
if(_number_of_occupied_sites == maxSites()){
return false;
}
try {
value_type v = placeSite_1nn_v2();
_occuption_probability = occupationProbability(); // for super class
return v != ULLONG_MAX;
}catch (OccupiedNeighbor& on){
//        on.what();
return false;
}

}

std::string getSignature() {
std::string s = "sq_lattice_site_percolation_ballistic_deposition_L1";
if(_periodicity)
s += "_periodic_";
else
s += "_non_periodic_";
return s;
}

};

/*********************
*
*/
class SitePercolationBallisticDeposition_L2_v2: public SitePercolationBallisticDeposition_v2{
public:
~SitePercolationBallisticDeposition_L2_v2() = default;
SitePercolationBallisticDeposition_L2_v2(value_type length, bool periodicity)
:SitePercolationBallisticDeposition_v2(length, periodicity){}

bool occupy() {
// if no site is available then return false

if(_number_of_occupied_sites == maxSites()){
return false;
}

try {

//            value_type v = placeSite_2nn_v0();
value_type v = placeSite_2nn_v1();
_occuption_probability = occupationProbability(); // for super class

return v != ULLONG_MAX;
}catch (OccupiedNeighbor& on){
//        on.what();
//        cout << "line : " << __LINE__ << endl;
return false;
}

}

std::string getSignature() {
std::string s = "sq_lattice_site_percolation_ballistic_deposition_L2";
if(_periodicity)
s += "_periodic_";
else
s += "_non_periodic_";
return s;
}

};

#endif //SITEPERCOLATION_PERCOLATION_H
\end{lstlisting}

The \textbf{src/percolation/percolation.cpp} file

\begin{lstlisting}[style=CStyle]
#include "percolation.h"

using namespace std;

/**
*
* @param length
*/
SqLatticePercolation::SqLatticePercolation(value_type length) {
if (length <= 2) {
/*
* Because if _length=2
* there are total of 4 distinct bond. But it should have been 8, i.e, (2 * _length * _length = 8)
*/
cerr << "_length <= 2 does not satisfy _lattice properties for percolation : line" << __LINE__ << endl;
exit(1);
}
_length = length;
value_type _length_squared = length * length;
_max_number_of_bonds = 2*_length_squared;
_max_number_of_sites = _length_squared;
_clusters = vector<Cluster>();

//    size_t seed = 0;
//    cerr << "automatic seeding is commented : line " << __LINE__ << endl;
auto seed = _random_device();
_random_generator.seed(seed); // seeding
cout << "seeding with " << seed << endl;
}


/**
*
*/
void SqLatticePercolation::viewCluster() {
cout << "clusters with numberOfBonds greater than 1" << endl;
value_type total_bonds{}, total_sites{};

for (value_type i{}; i != _clusters.size(); ++i) {
if(_clusters[i].empty()){
//            cout << "Empty cluster : line " << endl;
continue;
}
cout << "cluster [" << i << "] : " << '{' << endl;
cout << _clusters[i];
total_bonds += _clusters[i].numberOfBonds();
total_sites += _clusters[i].numberOfSites();

cout << '}' << endl;
}
cout << "Total bonds " << total_bonds << endl;
cout << "Total sites " << total_sites << endl;
}



/**
* Extended version of view_cluster
*/
void SqLatticePercolation::viewClusterExtended() {
cout << "clusters with numberOfBonds greater than 1" << endl;
value_type total_bonds{}, total_sites{};

std::vector<Index> sites;
std::vector<BondIndex> bonds;
for (value_type i{}; i != _clusters.size(); ++i) {
if(_clusters[i].empty()){
//            cout << "Empty cluster : line " << endl;
continue;
}
cout << "cluster [" << i << "] : ID (" << _clusters[i].get_ID() << "){" << endl;
// printing sites
sites = _clusters[i].getSiteIndices();
cout << "Sites : size (" << sites.size() << ") : ";
cout << '{';
for (auto a: sites) {
cout << a << ',';
}
cout << '}' << endl;

bonds = _clusters[i].getBondIndices();
cout << "Bonds : size (" << bonds.size() << ") : ";
cout << '{';
for (auto a: bonds) {
if (a.horizontal()) {
// horizontal bond
cout << _lattice.getBond({BondType::Horizontal, a.row_, a.column_}) << ',';
} else if (a.vertical()) {
// vertical bond
cout << _lattice.getBond({BondType::Vertical, a.row_, a.column_}) << ',';
} else {
cout << '!' << a << '!' << ','; // bond is not valid
}
}
cout << '}';

cout << endl;

total_bonds += _clusters[i].numberOfBonds();
total_sites += _clusters[i].numberOfSites();

cout << '}' << endl;
}
cout << "Total bonds " << total_bonds << endl;
cout << "Total sites " << total_sites << endl;
}

/**
*
* @param site
* @param bond
* @param total_site
* @param total_bond
*/
void
SqLatticePercolation::get_cluster_info(
vector<value_type> &site,
vector<value_type> &bond
) {
value_type total_site{}, total_bond{};
site.clear();
bond.clear();

unsigned long size = _clusters.size();
site.reserve(size);
bond.reserve(size);

value_type s, b;

for(value_type i{}; i < size; ++i){
if(_clusters[i].empty()){
//            cout << "Empty cluster : line " << endl;
continue;
}
s = _clusters[i].numberOfSites();
b = _clusters[i].numberOfBonds();
site.push_back(s);
bond.push_back(b);
total_site += s;
total_bond += b;
}
if(site.size() != bond.size()){
cout << "Size mismatched : line " << __LINE__ << endl;
}
//    cout << "total bonds " << total_bond << endl;
//    cout << "tatal sites " << total_site << endl;
if(type == 's'){
for(value_type j{total_bond}; j < maxBonds(); ++j){
bond.push_back(1); // cluster of length 1
total_bond += 1;
}
}
if(type == 'b'){
for(value_type j{total_site}; j < maxSites(); ++j){
total_site += 1;
site.push_back(1); // cluster of length 1
}
}
}

void SqLatticePercolation::reset() {
_lattice.reset();
_clusters.clear();
_index_sequence_position = 0;

_occuption_probability = 0;
// entropy
_entropy=0;
_entropy_current=0;
_total_relabeling = 0;
time_relabel = 0;
_cluster_count = 0;
_reached_critical = false;
}


/**
* Entropy calculation is performed here. The fastest method possible.
* Cluster size is measured by site.
* @return current entropy of the lattice
*/
double SqLatticePercolation::entropy_by_site() {
double H{}, mu ;

for(size_t i{}; i < _clusters.size(); ++i){
if(!_clusters[i].empty()){
mu = _clusters[i].numberOfSites() / double(_number_of_occupied_sites);
H += mu*log(mu);
}
}

return -H;
}

/**
* Entropy calculation is performed here. The fastest method possible.
* Cluster size is measured by site.
* @return current entropy of the lattice
*/
double SqLatticePercolation::entropy_by_bond() {
double H{}, mu ;

for(size_t i{}; i < _clusters.size(); ++i){
if(!_clusters[i].empty()){
mu = _clusters[i].numberOfBonds() / double(maxBonds());
H += mu*log(mu);
}
}

double number_of_cluster_with_size_one = maxBonds() - _bonds_in_cluster_with_size_two_or_more;
//    cout << " _bonds_in_cluster_with_size_two_or_more " << _bonds_in_cluster_with_size_two_or_more << " : line " << __LINE__ << endl;
mu = 1.0/double(maxBonds());
H += number_of_cluster_with_size_one * log(mu) * mu;

return -H;
}
\end{lstlisting}

The \textbf{src/percolation/percolation_site_v9.cpp} file

\begin{lstlisting}[style=CStyle]
#include <cstdlib>
#include <climits>
#include <unordered_set>
#include <mutex>

#include "percolation.h"

#include "../util/printer.h"
#include <omp.h>
#include <thread>
#include <algorithm>

#include "../util/time_tracking.h"

using namespace std;



/**
*
* @param length       : length of the lattice
* @param impure_sites : number of impure sites. cannot be greater than length*length
*/
SitePercolation_ps_v9::SitePercolation_ps_v9(value_type length, bool periodicity)
:SqLatticePercolation(length)
{
std::cout << "Constructing SitePercolation_ps_v9 object : line " << __LINE__ << endl;
SqLatticePercolation::set_type('s');

_periodicity = periodicity;
_index_sequence_position = 0;
_lattice = SqLattice(length, true, false, false, true);   // since it is a site percolation all bonds will be activated by default

min_index = 0;
max_index = length - 1;

index_sequence.resize(maxSites());
randomized_index.resize(maxSites());
_max_iteration_limit = maxSites();

initialize_index_sequence();
initialize();
randomize_v2();  // randomize the untouched_site_indices
}


/**
*
*/
void SitePercolation_ps_v9::initialize() {

// to improve performence
number_of_sites_to_span.reserve(maxSites());
number_of_bonds_to_span.reserve(maxSites());

_top_edge.reserve(length());
_bottom_edge.reserve(length());
_left_edge.reserve(length());
_right_edge.reserve(length());

//    randomized_index_sequence = index_sequence;
}


/**
* Called only once when the object is constructed for the first time
*/
void SitePercolation_ps_v9::initialize_index_sequence() {
value_type m{}, n{};
for (value_type i{}; i != index_sequence.size(); ++i) {
randomized_index[i] = i;
index_sequence[i] = Index(m, n);
++n;
if (n == length()) {
n = 0;
++m;
}
}
//for (value_type i{}; i != index_sequence.size(); ++i) {cout << index_sequence[i] << endl;}
}


/**
* Reset all calculated values and then call initiate()
* to initiallize for reuse
*
* caution -> it does not erase _calculation_flags, for it will be used for calculation purposes
*/
void SitePercolation_ps_v9::reset() {
SqLatticePercolation::reset();
// variables
_number_of_occupied_sites = 0;
_index_sequence_position = 0;
//    _first_spanning_cluster_id = -1;
_cluster_id = 0;
//    bonds_in_largest_cluster = 0;
//    sites_in_largest_cluster = 0;

// containers
//    randomized_index_sequence.clear();    // reseted in the initialize function

//    _number_of_occupied_sites.clear();
//    _entropy_by_bond.clear();
number_of_sites_to_span.clear();
number_of_bonds_to_span.clear();
//    spanning_cluster_ids.clear();
_spanning_sites.clear();
_wrapping_sites.clear();
//    wrapping_cluster_ids.clear();

_bonds_in_cluster_with_size_two_or_more = 0;
//    _id_largest_cluster = 0;

//    _id_last_modified_cluster = -1;

_index_last_modified_cluster = 0;  // id of the last modified cluster
//    _index_largest_cluster = 0;
_number_of_bonds_in_the_largest_cluster = 0;
_number_of_sites_in_the_largest_cluster = 0;
//    _cluster_id_set.clear();

// clearing edges
_top_edge.clear();
_bottom_edge.clear();
_left_edge.clear();
_right_edge.clear();

initialize();
randomize_v2();
time_relabel = 0;
_total_relabeling = 0;
}


/**
* Randomize the indices
*/
void SitePercolation_ps_v9::randomize_v2(){

std::shuffle(randomized_index.begin(), randomized_index.end(), _random_generator);
//    cout << "Index sequence : " << randomized_index_sequence << endl;
}


/*************************************************
* Calculation methods
*
***********************************/

/*
* Instead of calculating entropy for 1000s of cluster in every iteration
* just keep track of entropy change, i.e.,
* how much to subtract and how much to add.
*/
/**
* Must be called before merging the clusters
* @param found_index_set
*/
void SitePercolation_ps_v9::subtract_entropy_for_bond(const set<value_type> &found_index, int base){
double nob, mu_bond, H{};
if(base >= 0){
nob = _clusters[base].numberOfBonds();
mu_bond = nob / maxBonds();
H += log(mu_bond) * mu_bond;
}
for(auto x : found_index){
nob = _clusters[x].numberOfBonds();
mu_bond = nob / maxBonds();
H += log(mu_bond) * mu_bond;
}
_entropy -= -H;
}



/**
* Must be called after merging the clusters
* Cluster length is measured by bonds
* @param index
*/
void SitePercolation_ps_v9::add_entropy_for_bond(value_type index){
double nob = _clusters[index].numberOfBonds();
double mu_bond = nob / maxBonds();
double H = log(mu_bond) * mu_bond;
_entropy += -H;
}



/**
* Condition: must be called each time a site is placed
*/
void SitePercolation_ps_v9::track_numberOfBondsInLargestCluster() {

// calculating number of bonds in the largest cluster // by cluster index
// checking number of bonds
if(_clusters[_index_last_modified_cluster].numberOfBonds() > _number_of_bonds_in_the_largest_cluster){
_number_of_bonds_in_the_largest_cluster = _clusters[_index_last_modified_cluster].numberOfBonds();
}

}

/**
*
*/
void SitePercolation_ps_v9::track_numberOfSitesInLargestCluster(){

// calculating number of bonds in the largest cluster // by cluster index
// checking number of bonds
if(_clusters[_index_last_modified_cluster].numberOfSites() > _number_of_sites_in_the_largest_cluster){
_number_of_sites_in_the_largest_cluster = _clusters[_index_last_modified_cluster].numberOfSites();
}
}


/**
*
* @param neighbors         :
* @param found_index_set   : index of the clusters that will be merged together.
*                            Does not contain the base cluster index or id.
* @return                  : id of the base cluster
*/
int
SitePercolation_ps_v9::find_cluster_index_for_placing_new_bonds(
const vector<Index> &neighbors, std::set<value_type> &found_index_set
){
found_index_set.clear();
value_type size{}, tmp{}, index, base{ULONG_MAX};
int base_id{-1};
int id;
for (auto n: neighbors) {
id = _lattice.getGroupID(n);
if(id >=0) {
index = value_type(id);
tmp = _clusters[index].numberOfSites();
if(tmp > size){
size = tmp;
base_id = id;
base = index;
}

found_index_set.insert(index);

}
}
found_index_set.erase(base);
return base_id;
}


/**
* Last placed site is added to a cluster. If this connects other clusters then merge all
* cluster together to get one big cluster. All sites that are part of the other clusters
* are relabled according to the id of the base cluster.
* @param found_index_set : index of the clusters that are neighbors of the last placed site
* @param hv_bonds        : bonds that connects the last placed site and its neighbors
*                          and which are not part of any cluster of size larger than one
* @param site            : last placed site
* @param base_id         : id of the base cluster
* @return
*/
value_type SitePercolation_ps_v9::manage_clusters(
const set<value_type> &found_index_set,
vector<BondIndex> &hv_bonds,
Index &site,
int base_id
)
{


if (base_id != -1) {
value_type base = value_type(base_id); // converting here
_clusters[base].addSiteIndex(site);
int id_base = _clusters[base].get_ID();
vector<Index> neibhgors = _lattice.get_neighbor_site_indices(site);
// find which of the neighbors are of id_base as the base cluster
IndexRelative r;
for(auto n: neibhgors){
if(_lattice.getGroupID(n) == id_base){
// find relative index with respect to this site
r = getRelativeIndex(n, site);
break; // since first time r is set running loop is doing no good
}
}

// put_values_to_the_cluster new values in the 0-th found index
_clusters[base].insert(hv_bonds);
_lattice.getSite(site).relativeIndex(r);
_lattice.setGroupID(site, id_base); // relabeling for 1 site

// merge clusters with common values from all other cluster        // merge clusters with common values from all other cluster


for(value_type ers: found_index_set){

_total_relabeling += _clusters[ers].numberOfSites(); // only for debugging purposes
// perform relabeling on the sites
relabel_sites_v5(site, _clusters[ers]);

// store values of other found indices to the cluster
_clusters[base].insert_v2(_clusters[ers]);
_cluster_count--; // reducing number of clusters
_clusters[ers].clear(); // emptying the cluster

}
_index_last_modified_cluster = base;


} else {
// create new element for the cluster
_clusters.push_back(Cluster(_cluster_id));
value_type _this_cluster_index = _clusters.size() -1;
_lattice.setGroupID(site, _cluster_id); // relabeling for 1 site
_cluster_count++; // increasing number of clusters
_cluster_id++;
_clusters.back().insert(hv_bonds);
_clusters[_this_cluster_index].addSiteIndex(site);
_index_last_modified_cluster = _this_cluster_index;   // last cluster is the place where new bonds are placed

}
return _index_last_modified_cluster;
}





/**
* Relative index of site_new with respect to root
* @param root
* @param site_new
* @return
*/
IndexRelative SitePercolation_ps_v9::getRelativeIndex(Index root, Index site_new){
//    cout << "Entry \"SitePercolation_ps_v9::getRelativeIndex\" : line " << __LINE__ << endl;
int delta_x = -int(root.column_) + int(site_new.column_); // if +1 then root is on the right ??
int delta_y = int(root.row_) - int(site_new.row_); // if +1 then root is on the top ??


// normalizing delta_x
if(delta_x > 1){
delta_x /= -delta_x;
}
else if(delta_x < -1){
delta_x /= delta_x;
}

// normalizing delta_y
if(delta_y > 1){
delta_y /= -delta_y;
}else if(delta_y < -1){
delta_y /= delta_y;
}

IndexRelative indexRelative_root = _lattice.getSite(root).relativeIndex();
//    cout << "Relative index of root " << indexRelative_root << endl;
//    cout << "Delta x,y " << delta_x << ", " << delta_y << endl;
IndexRelative r =  {indexRelative_root.x_ + delta_x, indexRelative_root.y_ + delta_y};
//    cout << "Relative index of site_new " << r << endl;
return r;
}



/**
* Take a bond index only if the corresponding site is active
* takes longer? time than version 1?, i.e.,  connection()
* @param site
* @param site_neighbor
* @param bond_neighbor
*/
void SitePercolation_ps_v9::connection_v2(Index site, vector<Index> &site_neighbor, vector<BondIndex> &bond_neighbor)
{

value_type prev_column  = (site.column_ + length() - 1) % length();
value_type prev_row     = (site.row_ + length() - 1) % length();
value_type next_row     = (site.row_ + 1) % length();
value_type next_column  = (site.column_ + 1) % length();

if(!_periodicity){
// without periodicity
if (site.row_ == min_index) { // top edge including corners
if(site.column_ == min_index){
// upper left corner

site_neighbor.resize(2);
site_neighbor[0] = {site.row_, next_column};
site_neighbor[1] = {next_row, site.column_};

bond_neighbor.reserve(2);
if(!_lattice.getSite(site_neighbor[0]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Vertical, site.row_, site.column_});
}

return;

}
else if(site.column_ == max_index){
// upper right corner

site_neighbor.resize(2);
site_neighbor[0] = {site.row_, prev_column};
site_neighbor[1] = {next_row, site.column_};

bond_neighbor.reserve(2);
if(!_lattice.getSite(site_neighbor[0]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, prev_column});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Vertical, site.row_, site.column_});
}

return;
}
else{
// top edge excluding corners
site_neighbor.resize(3);
site_neighbor[0] = {site.row_, next_column};
site_neighbor[1] = {site.row_, prev_column};
site_neighbor[2] = {next_row, site.column_};

bond_neighbor.reserve(4);
if(!_lattice.getSite(site_neighbor[0]).isActive()) {
bond_neighbor.push_back({BondType::Horizontal, site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, prev_column});
}
if(!_lattice.getSite(site_neighbor[2]).isActive()){
bond_neighbor.push_back({BondType::Vertical,    site.row_, site.column_});
}

return;

}
}
else if (site.row_ == max_index) { // bottom edge including corners
if (site.column_ == min_index) {
// lower left corner
site_neighbor.resize(2);
site_neighbor[0] = {site.row_, next_column};
site_neighbor[1] = {prev_row, site.column_};

bond_neighbor.reserve(2);
if(!_lattice.getSite(site_neighbor[0]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Vertical, prev_row, site.column_});
}


return;

} else if (site.column_ == max_index) {
// lower right corner
site_neighbor.resize(2);
site_neighbor[0] = {site.row_, prev_column};
site_neighbor[1] = {prev_row, site.column_};

bond_neighbor.reserve(2);
if(!_lattice.getSite(site_neighbor[0]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, prev_column});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Vertical, prev_row, site.column_});
}

return;

} else {
// bottom edge excluding corners
//  bottom edge
site_neighbor.resize(3);
site_neighbor[0] = {site.row_, next_column};
site_neighbor[1] = {site.row_, prev_column};
site_neighbor[2] = {prev_row, site.column_};

bond_neighbor.reserve(3);
if(!_lattice.getSite(site_neighbor[0]).isActive()) {
bond_neighbor.push_back({BondType::Horizontal, site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, prev_column});
}
if(!_lattice.getSite(site_neighbor[2]).isActive()){
bond_neighbor.push_back({BondType::Vertical, prev_row, site.column_});
}

return;
}
}
/* site.x_ > min_index && site.x_ < max_index &&  is not possible anymore*/
else if (site.column_ == min_index) { // left edge not in the corners
site_neighbor.resize(3);
site_neighbor[0] = {site.row_, next_column};
site_neighbor[1] = {next_row, site.column_};
site_neighbor[2] = {prev_row, site.column_};

bond_neighbor.reserve(3);
if(!_lattice.getSite(site_neighbor[0]).isActive()) {
bond_neighbor.push_back({BondType::Horizontal, site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Vertical,    site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[2]).isActive()){
bond_neighbor.push_back({BondType::Vertical, prev_row, site.column_});
}

return;
}
else if (site.column_ == max_index) {
// right edge no corners

site_neighbor.resize(3);
site_neighbor[0] = {site.row_, prev_column};
site_neighbor[1] = {next_row, site.column_};
site_neighbor[2] = {prev_row, site.column_};

bond_neighbor.reserve(3);
if(!_lattice.getSite(site_neighbor[0]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, prev_column});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Vertical,    site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[2]).isActive()){
bond_neighbor.push_back({BondType::Vertical, prev_row, site.column_});
}

return;
}

}
// 1 level inside the lattice
// not in any the boundary
site_neighbor.resize(4);
site_neighbor[0] = {site.row_, next_column};
site_neighbor[1] = {site.row_, prev_column};
site_neighbor[2] = {next_row, site.column_};
site_neighbor[3] = {prev_row, site.column_};

bond_neighbor.reserve(4);
if(!_lattice.getSite(site_neighbor[0]).isActive()) {
bond_neighbor.push_back({BondType::Horizontal, site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[1]).isActive()){
bond_neighbor.push_back({BondType::Horizontal, site.row_, prev_column});
}
if(!_lattice.getSite(site_neighbor[2]).isActive()){
bond_neighbor.push_back({BondType::Vertical,    site.row_, site.column_});
}
if(!_lattice.getSite(site_neighbor[3]).isActive()) {
bond_neighbor.push_back({BondType::Vertical, prev_row, site.column_});
}

}



/**
*
* @param site
* @param edge
* @return
*/
bool SitePercolation_ps_v9::check_if_id_matches(Index site, const vector<Index> &edge){
for(auto s :edge){
if(_lattice.getGroupID(site) == _lattice.getGroupID(s)){
// no need to put the site here
return true;
}
}
return false;
}



/***********************************************
*  Placing sites
*
*****************************************/

/**
* All site placing method in one place
*
* @return true if operation is successfull
*/
bool SitePercolation_ps_v9::occupy() {
if(_index_sequence_position >= maxSites()){
return false;
}
Index site = selectSite();
placeSite_weighted(site);
_occuption_probability = occupationProbability(); // for super class
return true;
}

/***
* Index of the selected site must be provided with the argument
*
* Wrapping and spanning index arrangement is enabled.
* Entropy is calculated smoothly.
* Entropy is measured by site and bond both.
* @param current_site
* @return
*/
value_type SitePercolation_ps_v9::placeSite_weighted(Index current_site) {
// randomly choose a site
if (_number_of_occupied_sites == maxSites()) {
return ULONG_MAX;// unsigned long int maximum value
}

_last_placed_site = current_site;
_lattice.activate_site(current_site);
++_number_of_occupied_sites;
// find the bonds for this site
vector<BondIndex> bonds;
vector<Index>     sites;
connection_v2(current_site, sites, bonds);
_bonds_in_cluster_with_size_two_or_more += bonds.size();

// find one of hv_bonds in _clusters and add ever other value to that place. then erase other position
set<value_type> found_index_set;
int  base_id = find_cluster_index_for_placing_new_bonds(sites, found_index_set);

subtract_entropy_for_bond(found_index_set, base_id);  // tracking entropy change
value_type merged_cluster_index = manage_clusters(
found_index_set, bonds, current_site, base_id
);
add_entropy_for_bond(merged_cluster_index); // tracking entropy change
// running tracker
track_numberOfBondsInLargestCluster(); // tracking number of bonds in the largest cluster
track_numberOfSitesInLargestCluster();
return merged_cluster_index;
}

/***
* Index of the selected site must be provided with the argument
*
* Wrapping and spanning index arrangement is enabled.
* Entropy is calculated smoothly.
* Entropy is measured by site and bond both.
* @param current_site
* @return
*/
value_type SitePercolation_ps_v9::placeSite_weighted(
Index current_site,
vector<Index>& neighbor_sites,
vector<BondIndex>& neighbor_bonds
) {
// randomly choose a site
if (_number_of_occupied_sites == maxSites()) {
return ULONG_MAX;// unsigned long int maximum value
}
_bonds_in_cluster_with_size_two_or_more += neighbor_bonds.size();
_last_placed_site = current_site;
_lattice.activate_site(current_site);
++_number_of_occupied_sites;
// find one of hv_bonds in _clusters and add ever other value to that place. then erase other position
set<value_type> found_index_set;
int  base_id = find_cluster_index_for_placing_new_bonds(neighbor_sites, found_index_set);
subtract_entropy_for_bond(found_index_set, base_id);  // tracking entropy change
value_type merged_cluster_index = manage_clusters(
found_index_set, neighbor_bonds, current_site, base_id
);
add_entropy_for_bond(merged_cluster_index); // tracking entropy change
// running tracker
track_numberOfBondsInLargestCluster(); // tracking number of bonds in the largest cluster
track_numberOfSitesInLargestCluster();
return merged_cluster_index;
}



/**
*
* @return
*/
Index SitePercolation_ps_v9::selectSite(){
//    Index current_site = randomized_index_sequence[_index_sequence_position]; // old
value_type index = randomized_index[_index_sequence_position];
Index current_site = index_sequence[index]; // new process
++_index_sequence_position;
return current_site;
}


/***************************************************
* View methods
****************************************/


/**
*
*/
void SitePercolation_ps_v9::spanningIndices() const {
cout << "Spanning Index : id" << endl;
for(Index i: _spanning_sites){
cout << "Index " << i << " : id " << _lattice.getGroupID(i) << endl;
}
}

void SitePercolation_ps_v9::wrappingIndices() const {
cout << "Wrapping Index : id : relative index" << endl;
for(auto i: _wrapping_sites){
cout << "Index " << i << " : id "
<< _lattice.getGroupID(i)
<< " relative index : " << _lattice.getSite(i).relativeIndex() << endl;
}
}


/****************************************
* Spanning Detection
****************************************/


/**
* success : gives correct result
* length       time
* 200          7.859000 sec
* 500          2 min 18.874000 sec
* only check for the cluster id of the recently placed site
* @param site : Check spanning for this argument
* @return
*/
bool SitePercolation_ps_v9::detectSpanning_v6(const Index& site) {
//    cout << "Entry -> detectSpanning_v4() : line " << __LINE__ << endl;
if(_periodicity) {
cout << "Cannot detect spanning if _periodicity if ON: line " << __LINE__ << endl;
return false;
}
if(_reached_critical ){
return true;  // we have already reached critical point
}

// first check if the site with a cluster id is already a spanning site
for(const Index& ss: _spanning_sites){
if(_lattice.getSite(ss).get_groupID() == _lattice.getSite(site).get_groupID()){
//            cout << "Already a spanning site : line " << __LINE__ << endl;
return true;
}
}

// only check for the newest site placed
if(site.row_ == min_index){ // top index
if(!check_if_id_matches(site, _top_edge)) {
_top_edge.push_back(site);
}
}
else if(site.row_ == max_index){
if(!check_if_id_matches(site, _bottom_edge)){
_bottom_edge.push_back(site);
}
}

// checking column indices for Left-Right boundary
if(site.column_ == min_index){ // left edge
if(!check_if_id_matches(site, _left_edge)) {
_left_edge.push_back(site);
}
}
else if(site.column_ == max_index){
if(!check_if_id_matches(site, _right_edge)) {
_right_edge.push_back(site);
}
}

if(_number_of_occupied_sites < length()){
//        cout << "Not enough site to span : line " << __LINE__ << endl;
return false;
}


vector<Index>::iterator it_top = _top_edge.begin();
vector<Index>::iterator it_bot = _bottom_edge.begin();
bool found_spanning_site = false;
int id = _lattice.getGroupID(site);

if(_top_edge.size() < _bottom_edge.size()){
// if matched found on the smaller edge look for match in the larger edge
for(; it_top < _top_edge.end(); ++it_top){
if(id == _lattice.getGroupID(*it_top)){
for(; it_bot < _bottom_edge.end(); ++it_bot){
if(id == _lattice.getGroupID(*it_bot)){
// match found !
if(!check_if_id_matches(*it_top ,_spanning_sites)) {
_reached_critical = true;
_spanning_sites.push_back(*it_top);
}
found_spanning_site = true;
_bottom_edge.erase(it_bot);
}
}

if(found_spanning_site){
found_spanning_site = false;
_top_edge.erase(it_top);
}

}
}
}else{
for (; it_bot < _bottom_edge.end(); ++it_bot) {
if (id == _lattice.getGroupID(*it_bot)) {
for (; it_top < _top_edge.end(); ++it_top) {
if (id == _lattice.getGroupID(*it_top)) {
// match found !
if (!check_if_id_matches(*it_top, _spanning_sites)) {
_reached_critical = true;
_spanning_sites.push_back(*it_top);
}
found_spanning_site = true;
_top_edge.erase(it_top);
}
}
if(found_spanning_site){
found_spanning_site = false;
_bottom_edge.erase(it_top);
}
}
}

}

found_spanning_site = false;
vector<Index>::iterator it_lft = _left_edge.begin();
vector<Index>::iterator it_rht = _right_edge.begin();

if(_left_edge.size() < _right_edge.size()){
for(; it_lft < _left_edge.end(); ++it_lft) {
if (id == _lattice.getGroupID(*it_lft)) {
for (; it_rht < _right_edge.end(); ++it_rht) {
if (id == _lattice.getGroupID(*it_rht)) {
if (!check_if_id_matches(*it_lft, _spanning_sites)) {
_spanning_sites.push_back(*it_lft);
_reached_critical = true;
}
found_spanning_site = true;
_right_edge.erase(it_rht);
}
}
if (found_spanning_site) {
found_spanning_site = false;
_left_edge.erase(it_lft);
}
}
}
}else{
for (; it_rht < _right_edge.end(); ++it_rht) {
if (id == _lattice.getGroupID(*it_rht)) {
for(; it_lft < _left_edge.end(); ++it_lft) {
if (id == _lattice.getGroupID(*it_lft)) {
if (!check_if_id_matches(*it_lft, _spanning_sites)) {
_spanning_sites.push_back(*it_lft);
_reached_critical = true;
}
found_spanning_site = true;
_left_edge.erase(it_lft);
}
}
if (found_spanning_site) {
found_spanning_site = false;
_right_edge.erase(it_rht);
}
}
}
}


// now do the matching with left and right for horizontal spanning
// meaning new site is added to _spanning_sites so remove them from top and bottom edges



// filter spanning ids


return !_spanning_sites.empty();

}



/***********************************
* Wrapping Detection
**********************************/
/**
* Wrapping is detected here using the last placed site
* @return bool. True if wrapping occured.
*/
bool SitePercolation_ps_v9::detectWrapping() {
Index site = lastPlacedSite();
// only possible if the cluster containing 'site' has sites >= length of the lattice
if(_number_of_occupied_sites < length()){
return false;
}

if(_reached_critical){
return true; // reached critical in previous step
}
// check if it is already a wrapping site
int id = _lattice.getGroupID(site);
int tmp_id{};
for (auto i: _wrapping_sites){
tmp_id = _lattice.getGroupID(i);
if(id == tmp_id ){
return true;
}
}

// get four neighbors of site always. since wrapping is valid if periodicity is implied
vector<Index> sites = _lattice.get_neighbor_site_indices(site);

if(sites.size() < 2){ // at least two neighbor of  site is required
return false;
}else{
IndexRelative irel = _lattice.getSite(site).relativeIndex();
//        cout << "pivot's " << site << " relative " << irel << endl;
IndexRelative b;
for (auto a:sites){
if(_lattice.getGroupID(a) != _lattice.getGroupID(site)){
// different cluster
continue;
}
// belongs to the same cluster
b = _lattice.getSite(a).relativeIndex();
//            cout << "neibhbor " << a << " relative " << b << endl;
if(abs(irel.x_ - b.x_) > 1 || abs(irel.y_ - b.y_) > 1){
//                cout << "Wrapping : line " << __LINE__ << endl;
_wrapping_sites.push_back(site);
_reached_critical = true;
return true;
}
}
}
// if %_wrapping_indices is not empty but wrapping is not detected for the current site (%site)
// that means there is wrapping but not for the %site
return !_wrapping_sites.empty();
}

/********************************************************************
* Relabeling
*
*********************************************************************/
/**
* Relabels site and also reassign relative index to the relabeled sites
*
* @param site_a  : last added site index of the base cluster
* @param clstr_b : 2nd cluster, which to be merged withe the root
*/
void SitePercolation_ps_v9::relabel_sites_v5(Index site_a, const Cluster& clstr_b) {
const vector<Index> sites = clstr_b.getSiteIndices();
int id_a = _lattice.getGroupID(site_a);
int id_b = clstr_b.get_ID();
Index b = clstr_b.getRootSite();

// get four site_b of site_a
vector<Index> sites_neighbor_a = _lattice.get_neighbor_site_indices(site_a);
Index site_b;
IndexRelative relative_index_b_after;
bool flag{false};
// find which site_b has id_a of clstr_b
for(auto n: sites_neighbor_a){
if(id_b == _lattice.getGroupID(n)){
// checking id_a equality is enough. since id_a is the id_a of the active site already.
relative_index_b_after = getRelativeIndex(site_a, n);
site_b = n;
flag = true;
break;
}
}
if(!flag){
cout << "No neibhgor found! : line " << __LINE__ << endl;
}

IndexRelative relative_site_a = _lattice.getSite(site_a).relativeIndex();
// with this delta_a and delta_y find the relative index of site_b while relative index of site_a is known
IndexRelative relative_site_b_before = _lattice.getSite(site_b).relativeIndex();
int delta_x_ab = relative_index_b_after.x_ - relative_site_b_before.x_;
int delta_y_ab = relative_index_b_after.y_ - relative_site_b_before.y_;
relabel_sites(sites, id_a, delta_x_ab, delta_y_ab);
}



void SitePercolation_ps_v9::relabel_sites(const vector<Index> &sites, int id_a, int delta_x_ab, int delta_y_ab)  {
int x, y;
Index a;
IndexRelative relative_site__a;
for (value_type i = 0; i < sites.size(); ++i) {
a = sites[i];
_lattice.setGroupID(a, id_a);
relative_site__a = _lattice.getSite(a).relativeIndex();
x = relative_site__a.x_ + delta_x_ab;
y = relative_site__a.y_ + delta_y_ab;
_lattice.getSite(a).relativeIndex(x, y);
}
}



/**********************************************
* Information about current state of Class
**********************************************/

/**
* Entropy calculation is performed here. The fastest method possible.
* Cluster size is measured by bond.
* @return current entropy of the lattice
*/
double SitePercolation_ps_v9::entropy() {
double H{};
double number_of_cluster_with_size_one = maxBonds() - _bonds_in_cluster_with_size_two_or_more;
//    cout << " _bonds_in_cluster_with_size_two_or_more " << _bonds_in_cluster_with_size_two_or_more << " : line " << __LINE__ << endl;
double mu = 1.0/double(maxBonds());
H += number_of_cluster_with_size_one * log(mu) * mu;
H *= -1;
_entropy_current =  _entropy + H;
return _entropy_current;
}



/**
* Only applicable if the number of bonds in the largest cluster is calculated when occupying the lattice.
* Significantly efficient than the previous version numberOfBondsInTheLargestCluster()
* @return
*/
value_type SitePercolation_ps_v9::numberOfBondsInTheLargestCluster_v2() {
//    return _clusters[_index_largest_cluster].numberOfBonds();
return _number_of_bonds_in_the_largest_cluster;
}



/**
*
* @return
*/
value_type SitePercolation_ps_v9::numberOfSitesInTheLargestCluster() {
value_type  len{}, nob{};
for(auto c: _clusters){
nob = c.numberOfSites();
if (len < nob){
len = nob;
}
}
_number_of_sites_in_the_largest_cluster = len;
return len;
}


/**********************************
* Spanning methods
**********************************/

/**
*
* @return
*/
value_type SitePercolation_ps_v9::numberOfSitesInTheSpanningClusters_v2() {

if(! _spanning_sites.empty()){
int id = _lattice.getGroupID(_spanning_sites.front());
if(id >= 0) {
return _clusters[id].numberOfSites();
}
}
return 0;
}


/**
*
* @return
*/
value_type SitePercolation_ps_v9::numberOfBondsInTheSpanningClusters_v2() {
if(!_spanning_sites.empty()){
//        cout << "number of spanning sites " << _spanning_sites.size() << " : line " << __LINE__ << endl;
int id = _lattice.getGroupID(_spanning_sites.front());
if(id >= 0) {
return _clusters[id].numberOfBonds();
}
}
return 0;
}

/**
*
* @return
*/
value_type SitePercolation_ps_v9::numberOfSitesInTheWrappingClusters(){
value_type nos{};
int id{};
for(auto i: _wrapping_sites){
id = _lattice.getGroupID(i);
if(id >= 0) {
nos += _clusters[id].numberOfSites();
}
}
return nos;
}

/**
*
* @return
*/
value_type SitePercolation_ps_v9::numberOfBondsInTheWrappingClusters(){
value_type nob{};
int id{};
for(auto i: _wrapping_sites){
id = _lattice.getGroupID(i);
if(id >= 0) {
nob += _clusters[id].numberOfBonds();
}
}
return nob;
}


std::string SitePercolation_ps_v9::getSignature() {
string s = "sq_lattice_site_percolation";
if(_periodicity)
s += "_periodic_";
else
s += "_non_periodic_";
return s;
}

/**
*
* @param filename
* @param only_spanning
*/
void SitePercolation_ps_v9::writeVisualLatticeData(const string &filename, bool only_spanning) {
std::ofstream fout(filename);
ostringstream header_info;
header_info << "{"
<< "\"length\":" << length()
<< ",\"signature\":\"" << getSignature() << "\""
<< ",\"x\":\"" << lastPlacedSite().column_ << "\""
<< ",\"y\":\"" << lastPlacedSite().row_ << "\""
<< "}" ;

fout << "#" << header_info.str() << endl;
fout << "#<x>,<y>,<color>" << endl;
fout << "# color=0 -means-> unoccupied site" << endl;
int id{-1};
if(!_spanning_sites.empty()){
id = _lattice.getGroupID(_spanning_sites.front());
}
else if(!_wrapping_sites.empty()){
id = _lattice.getGroupID(_wrapping_sites.front());
}

if(only_spanning){
if(id < 0){
cerr << "id < 0 : line " << __LINE__ << endl;
}
vector<Index> sites = _clusters[id].getSiteIndices();
for(auto s: sites){
fout << s.column_ << ',' << s.row_ << ',' << id << endl;
}
}
else {
for (value_type y{}; y != length(); ++y) {
for (value_type x{}; x != length(); ++x) {
id = _lattice.getGroupID({y, x});
if(id != -1) {
fout << x << ',' << y << ',' << id << endl;
}
}
}
}
fout.close();
}

\end{lstlisting}

The \textbf{src/percolation/percolation_site_ballistic_deps_v2.cpp} file

\begin{lstlisting}[style=CStyle]
#include <cstdlib>
#include <climits>

#include "percolation.h"

using namespace std;

/**
*
* @param length
*/
SitePercolationBallisticDeposition_v2::SitePercolationBallisticDeposition_v2(value_type length, bool periodicity)
: SitePercolation_ps_v9(length, periodicity )
{

std::cout << "Constructing SitePercolationBallisticDeposition_v2 object : line " << __LINE__ << endl;

initialize_indices();
indices_tmp = indices;
//    randomize_index();
}

/**
*
*/
void SitePercolationBallisticDeposition_v2::reset() {
SitePercolation_ps_v9::reset();
indices_tmp = indices;
}

/**
* Called only once when the object is constructed for the first time
*/
void SitePercolationBallisticDeposition_v2::initialize_indices() {
indices = vector<value_type>(maxSites());
for(value_type i{}; i != indices.size(); ++i){
indices[i] = i; // assign index first
}
}



/*******************************************
* Site selection methods
*/

/**
*
* @param sites
* @param bonds
* @return
*/
Index SitePercolationBallisticDeposition_v2::select_site(vector<Index> &sites, vector<BondIndex> &bonds) {
// randomly choose a site
value_type r = std::rand() % (indices_tmp.size());

Index current_site = index_sequence[indices_tmp[r]];
cout << "current site " << current_site << endl;
// find the bonds for this site

if (_lattice.getSite(current_site).isActive()){
indices_tmp.erase(indices_tmp.begin()+r);

throw OccupiedNeighbor{"all of the 1nd neighbors are occupied : line " + std::to_string(__LINE__)};
}

cout << "choosing " << current_site << " out of the neighbors : line " << __LINE__ << endl;
sites.clear();
bonds.clear();
connection_v2(current_site, sites, bonds);
return current_site;
}

/**
*
* @param sites
* @param bonds
* @return
*/
Index SitePercolationBallisticDeposition_v2::select_site_upto_1nn(
vector<Index> &sites, vector<BondIndex> &bonds
) {
// randomly choose a site
value_type r = _random_generator() % (indices_tmp.size());

Index current_site = index_sequence[indices_tmp[r]];
//    cout << "current site " << current_site << endl;
// find the bonds for this site

//    connection_v1(current_site, sites, bonds);
connection_v2(current_site, sites, bonds);

if (_lattice.getSite(current_site).isActive()){ // if the current site is occupied or active
value_type r2 = _random_generator() % (sites.size());
current_site = sites[r2]; // select one of the neighbor randomly

if(_lattice.getSite(current_site).isActive()){
// if the neighbor is also occupied cancel current step
bool flag = true;
//            cout << "if one of the neighbor is inactive. it's engouh to go on" << endl;
for(auto s : sites){
//                cout << s << "->";
if(!_lattice.getSite(s).isActive()){
// if one of the neighber is unoccupied then
flag = false;
//                    cout << " inactive" << endl;
break;
}
//                cout << " active"<< endl;
}
if(flag){
// erase the index, since its four neighbors are occupied
indices_tmp.erase(indices_tmp.begin()+r);
throw OccupiedNeighbor{"all of the 1nd neighbors are occupied : line " + std::to_string(__LINE__)};
}
throw OccupiedNeighbor{"selected 1st neighbor is occupied : line " + std::to_string(__LINE__)};
}
}

//    cout << "choosing " << current_site << " out of the neighbors : line " << __LINE__ << endl;
sites.clear();
bonds.clear();
connection_v2(current_site, sites, bonds);
return current_site;
}



/**
* Select neighbor upto 2nd nearest neighbor
* uses direcion of motion when selecting 2nd nearest neighbor
* @param r : index of sites in the randomized array
* @param sites
* @param bonds
* @return
*/
Index SitePercolationBallisticDeposition_v2::select_site_upto_2nn(
vector<Index> &sites, vector<BondIndex> &bonds
){
value_type r = _random_generator() % (indices_tmp.size());

Index central_site = index_sequence[indices_tmp[r]];
Index selected_site;
// find the bonds for this site


connection_v2(central_site, sites, bonds);

if (_lattice.getSite(central_site).isActive()){
bool flag_nn1 = true; // true means all 1st nearest neighbors are occupied
bool flag_nn2 = true; // true means all 2nd nearest neighbors are occupied
//        cout << "if one of the neighbor is inactive. it's engouh to go on" << endl;
for(auto s : sites){
//            cout << s << "->";
if(!_lattice.getSite(s).isActive()){
// if one of the neighber is unoccupied then
flag_nn1 = false;
//                cout << " inactive" << endl;
break;
}
//            cout << " active"<< endl;
}

value_type r2 = _random_generator() % (sites.size());
Index nn1 = sites[r2]; // select one of the neighbor randomly
//        cout << "nn1 " << nn1 << " : line " << __LINE__ <<endl;
Index nn2;
if(_lattice.getSite(nn1).isActive()){
// if the neighbor is also occupied then choose the 2nd nearest neighbor in the direction of motion
nn2 = get_2nn_in_1nn_direction(central_site, nn1, length());
if(!_periodicity){
// if periodic boundary condition is not enabled then sites on the opposite edges will not contribute
vector<Index> tmp_sites;
vector<BondIndex> tmp_bonds;
// will find all possible neighbors of the selected first nearest neighbor
connection_v2(nn1, tmp_sites, tmp_bonds);
bool valid{false};
for(auto s: tmp_sites){
if(nn2 == s){
//                        cout << "valid 2nd nearest neighbor : line " << __LINE__ << endl;
valid = true;
break;
}
}
if(!valid){
throw InvalidNeighbor{"invalid 2nd nearest neighbor : line " + std::to_string(__LINE__)};
}
}
//            cout << "nn2 " << nn2 << " : line " << __LINE__ <<endl;
// if it is also occupied the skip the step
if(_lattice.getSite(nn2).isActive()) {
flag_nn2 = true;

vector<Index> nn2_sites = get_2nn_s_in_1nn_s_direction(central_site, sites, length());
for(auto x: nn2_sites){
if(!_lattice.getSite(x).isActive()){
flag_nn2 = false;
//                        cout << "inactive";
break;
}
}

if(flag_nn1 && flag_nn2){
// erase the index, since its 1st nearest neighbors are occupied
// and 2nd nearest neighbors are also occupied
indices_tmp.erase(indices_tmp.begin()+r);
}

throw OccupiedNeighbor{"2nd neighbor is also occupied : line " + std::to_string(__LINE__)};
}else{
selected_site = nn2;
}
}else {
selected_site = nn1;
}

sites.clear();
bonds.clear();

connection_v2(selected_site, sites, bonds);
}else{
selected_site = central_site;
}
return selected_site;
}



/********************************************************
* SitePercolationBallisticDeposition_v2
* select upto 1st nearest neighbor
*/

/**
*
* @return
*/
bool SitePercolationBallisticDeposition_v2::occupy() {
// if no site is available then return false

if(_number_of_occupied_sites == maxSites()){
return false;
}

try {

value_type v = placeSite_1nn_v2();
_occuption_probability = occupationProbability(); // for super class


return v != ULLONG_MAX;
}catch (OccupiedNeighbor& on){
//        on.what();
//        cout << "line : " << __LINE__ << endl;
return false;
}

}



/**
*
* 1. Randomly select a site from all sites
* 2. If it is not occupied occupy it.
* 3. If it is occupied select one of the 4 neighbor to occupy
* 4. If the selected neighbor is also occupied cancel current step
* 4. form cluster and track all informations
* 5. go to step 1
* 6. untill spanning cluster appears or no unoccupied site
*/
value_type SitePercolationBallisticDeposition_v2::placeSite_1nn_v2() {

vector<BondIndex> bonds;
vector<Index>     sites;

_last_placed_site = select_site_upto_1nn(sites, bonds);

return placeSite_weighted(_last_placed_site, sites, bonds);
}

/**
*
* @return
*/
value_type SitePercolationBallisticDeposition_v2::placeSite_2nn_v1() {
vector<BondIndex> bonds;
vector<Index>     sites;

try {
_last_placed_site = select_site_upto_2nn(sites, bonds);
return placeSite_weighted(_last_placed_site, sites, bonds);
//    return placeSite_v11(_last_placed_site);
}catch (OccupiedNeighbor& e){
//        cout << "Exception !!!!!!!!!!!!!!!!!!" << endl;
//        e.what();
}catch (InvalidNeighbor& b){
//        cout << "Exception !!!!!!!!!!!!!!!!!!" << endl;
//        b.what();
}
return ULONG_MAX;
}
\end{lstlisting}